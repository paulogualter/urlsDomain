#!/bin/bash

# =============================================================================
# SUBDOMAIN FINDER - Versão Simplificada
# Versão sem configurações restritivas que podem causar problemas
# =============================================================================

# Cores
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Configura PATH automaticamente
export PATH="$HOME/.local/bin:$PATH:$HOME/go/bin"

# Banner
show_banner() {
    echo -e "${BLUE}"
    cat << 'EOF'
 ██╗   ██╗██████╗ ██╗     ███████╗██████╗  ██████╗ ███╗   ███╗ █████╗ ██╗███╗   ██╗
██║   ██║██╔══██╗██║     ██╔════╝██╔══██╗██╔═══██╗████╗ ████║██╔══██╗██║████╗  ██║
██║   ██║██████╔╝██║     ███████╗██║  ██║██║   ██║██╔████╔██║███████║██║██╔██╗ ██║
██║   ██║██╔══██╗██║     ╚════██║██║  ██║██║   ██║██║╚██╔╝██║██╔══██║██║██║╚██╗██║
╚██████╔╝██║  ██║███████╗███████║██████╔╝╚██████╔╝██║ ╚═╝ ██║██║  ██║██║██║ ╚████║
 ╚═════╝ ╚═╝  ╚═╝╚══════╝╚══════╝╚═════╝  ╚═════╝ ╚═╝     ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═══╝
                                                                                  
                            [AUTOR    : eb0x         ]
                            [YOU TUBE : opaulogualter]
                            [INSTAGRAM: opaulogualter]
                              [-------++++++-------]
____________________________________[++++++++]____________________________________
EOF
    echo -e "${NC}"
}

# Função para logging
log() {
    local level="$1"
    shift
    local message="$*"
    local timestamp=$(date '+%H:%M:%S')
    
    case "$level" in
        "INFO")  echo -e "${GREEN}[$timestamp] [INFO]${NC} $message" ;;
        "WARN")  echo -e "${YELLOW}[$timestamp] [WARN]${NC} $message" ;;
        "ERROR") echo -e "${RED}[$timestamp] [ERROR]${NC} $message" ;;
    esac
}

# Verifica dependências
check_dependencies() {
    local deps=("subfinder" "assetfinder" "sublist3r" "httpx" "anew" "dig")
    local missing=()
    
    log "INFO" "Verificando dependências..."
    
    for dep in "${deps[@]}"; do
        if ! command -v "$dep" &> /dev/null; then
            missing+=("$dep")
        else
            echo -e "${GREEN}✓ $dep encontrado${NC}"
        fi
    done
    
    if [ ${#missing[@]} -gt 0 ]; then
        log "ERROR" "Dependências não encontradas: ${missing[*]}"
        exit 1
    fi
    
    log "INFO" "Todas as dependências estão instaladas"
}

# Função para mostrar barra de progresso
show_progress() {
    local current="$1"
    local total="$2"
    local desc="$3"
    local width=50
    local percentage=$((current * 100 / total))
    local filled=$((current * width / total))
    local empty=$((width - filled))
    
    printf "\r${GREEN}[INFO]${NC} %s [%s%s] %d%% (%d/%d)" \
        "$desc" \
        "$(printf "%*s" $filled | tr ' ' '=')" \
        "$(printf "%*s" $empty | tr ' ' '-')" \
        "$percentage" \
        "$current" \
        "$total"
}

# Função para mostrar uso
show_usage() {
    echo "Uso: $0 [OPÇÕES] <domínio>"
    echo ""
    echo "OPÇÕES:"
    echo "  -o, --output FILE     Salvar resultados em arquivo"
    echo "  -s, --status CODE     Excluir códigos de status (ex: 400,403,404)"
    echo "  -t, --threads NUM     Número de threads (padrão: 50)"
    echo "  -T, --timeout SEC     Timeout em segundos (padrão: 30)"
    echo "  -v, --verbose         Modo verboso"
    echo "  -h, --help            Mostrar esta ajuda"
    echo ""
    echo "EXEMPLOS:"
    echo "  $0 exemplo.com.br"
    echo "  $0 -o resultados.txt exemplo.com.br"
    echo "  $0 -s 400,403,404 -t 100 exemplo.com.br"
    echo "  $0 -v -o output.txt -T 60 exemplo.com.br"
}

# Função principal
main() {
    local domain=""
    local output_file=""
    local exclude_sc=""
    local threads=50
    local timeout=30
    local verbose=false
    
    # Parse de argumentos
    while [[ $# -gt 0 ]]; do
        case $1 in
            -o|--output)
                output_file="$2"
                shift 2
                ;;
            -s|--status)
                exclude_sc="$2"
                shift 2
                ;;
            -t|--threads)
                threads="$2"
                shift 2
                ;;
            -T|--timeout)
                timeout="$2"
                shift 2
                ;;
            -v|--verbose)
                verbose=true
                shift
                ;;
            -h|--help)
                show_usage
                exit 0
                ;;
            -*)
                echo "Opção desconhecida: $1"
                show_usage
                exit 1
                ;;
            *)
                if [ -z "$domain" ]; then
                    domain="$1"
                else
                    echo "Múltiplos domínios especificados"
                    show_usage
                    exit 1
                fi
                shift
                ;;
        esac
    done
    
    if [ -z "$domain" ]; then
        echo "Domínio não especificado"
        show_usage
        exit 1
    fi
    
    local temp_dir="/tmp/subdomain_finder_$$"
    
    # Cria diretório temporário
    mkdir -p "$temp_dir"
    
    # Mostra banner
    show_banner
    
    # Verifica dependências
    check_dependencies
    
    log "INFO" "Iniciando descoberta de subdomínios para: $domain"
    
    # Executa ferramentas com barra de progresso
    echo ""
    show_progress 0 3 "Executando subfinder..."
    subfinder -d "$domain" -silent > "$temp_dir/subfinder.txt" 2>/dev/null || true
    show_progress 1 3 "Executando assetfinder..."
    assetfinder --subs-only "$domain" > "$temp_dir/assetfinder.txt" 2>/dev/null || true
    show_progress 2 3 "Executando sublist3r..."
    sublist3r -d "$domain" -o "$temp_dir/sublist3r.txt" >/dev/null 2>&1 || true
    show_progress 3 3 "Combinando resultados..."
    
    # Combina resultados
    cat "$temp_dir"/*.txt 2>/dev/null | anew > "$temp_dir/subs.txt" || touch "$temp_dir/subs.txt"
    
    local count=$(wc -l < "$temp_dir/subs.txt" 2>/dev/null || echo "0")
    echo ""
    log "INFO" "Descoberta inicial: $count subdomínios encontrados"
    
    # Validação com httpx
    if [ -s "$temp_dir/subs.txt" ]; then
        echo ""
        log "INFO" "Validando subdomínios com httpx..."
        
        # Detecta qual httpx usar (projectdiscovery)
        local httpx_bin=""
        # Procura o httpx do projectdiscovery em locais específicos
        for path in "$HOME/go/bin/httpx" "/usr/local/bin/httpx" "/opt/homebrew/bin/httpx" "/System/Volumes/Data/Users/paulogualter/Library/Python/3.9/bin/httpx"; do
            if [ -x "$path" ] && "$path" --help 2>&1 | grep -q "retryablehttp"; then
                httpx_bin="$path"
                break
            fi
        done
        
        if [ -z "$httpx_bin" ]; then
            log "WARN" "httpx do projectdiscovery não encontrado, pulando validação"
            touch "$temp_dir/validated.txt"
        else
            # Constrói comando httpx (sem cores)
            local httpx_cmd="$httpx_bin -silent -no-color -server -ip -sc -title -threads $threads -timeout $timeout"
        
        if [ -n "$exclude_sc" ]; then
            httpx_cmd="$httpx_cmd -fc $exclude_sc"
        fi
        
        # Executa httpx com barra de progresso
        local total_subs=$(wc -l < "$temp_dir/subs.txt")
        local current=0
        
        while IFS= read -r subdomain; do
            current=$((current + 1))
            show_progress "$current" "$total_subs" "Validando $subdomain"
            echo "$subdomain" | eval "$httpx_cmd" >> "$temp_dir/validated.txt" 2>/dev/null || true
        done < "$temp_dir/subs.txt"
        
            echo ""
            log "INFO" "Validação concluída"
        fi
    else
        touch "$temp_dir/validated.txt"
    fi
    
    # Mostra resultados
    echo -e "\n${GREEN}═══════════════════════════════════════════════════════════════${NC}"
    echo -e "${GREEN}                    RESULTADOS FINAIS${NC}"
    echo -e "${GREEN}═══════════════════════════════════════════════════════════════${NC}\n"
    
    if [ -s "$temp_dir/validated.txt" ]; then
        # Exibe resultados em formato de tabela
        echo -e "${BLUE}┌─────────────────────────────────────────────────────────────────────────────────────────────────────────┐${NC}"
        printf "${BLUE}│ ${GREEN}%-50s ${BLUE}│ ${GREEN}%-8s ${BLUE}│ ${GREEN}%-15s ${BLUE}│ ${GREEN}%-20s ${BLUE}│ ${GREEN}%-30s ${BLUE}│${NC}\n" "URL" "STATUS" "IP" "SERVER" "TITLE"
        echo -e "${BLUE}├─────────────────────────────────────────────────────────────────────────────────────────────────────────┤${NC}"
        
        while IFS= read -r line; do
            # Parse da linha do httpx (formato: URL [status] [title] [server] [ip])
            url=$(echo "$line" | awk '{print $1}')
            
            # Extrai campos usando awk para parsing mais robusto
            status=$(echo "$line" | awk -F'[][]' '{print $2}' || echo "N/A")
            title=$(echo "$line" | awk -F'[][]' '{print $4}' || echo "N/A")
            server=$(echo "$line" | awk -F'[][]' '{print $6}' || echo "N/A")
            ip=$(echo "$line" | awk -F'[][]' '{print $8}' || echo "N/A")
            
            # Trunca strings muito longas
            url=$(echo "$url" | cut -c1-50)
            server=$(echo "$server" | cut -c1-20)
            title=$(echo "$title" | cut -c1-30)
            
            # Cores baseadas no status code
            if [[ "$status" =~ ^[2][0-9][0-9]$ ]]; then
                status_color="${GREEN}"
            elif [[ "$status" =~ ^[3][0-9][0-9]$ ]]; then
                status_color="${YELLOW}"
            elif [[ "$status" =~ ^[4][0-9][0-9]$ ]]; then
                status_color="${RED}"
            elif [[ "$status" =~ ^[5][0-9][0-9]$ ]]; then
                status_color="${RED}"
            else
                status_color="${NC}"
            fi
            
            printf "${BLUE}│ ${NC}%-50s ${BLUE}│ ${status_color}%-8s ${BLUE}│ ${NC}%-15s ${BLUE}│ ${NC}%-20s ${BLUE}│ ${NC}%-30s ${BLUE}│${NC}\n" "$url" "$status" "$ip" "$server" "$title"
        done < "$temp_dir/validated.txt"
        
        echo -e "${BLUE}└─────────────────────────────────────────────────────────────────────────────────────────────────────────┘${NC}"
        
        local validated_count=$(wc -l < "$temp_dir/validated.txt")
        echo -e "\n${CYAN}Total de Subdomínios Válidos: ${YELLOW}$validated_count${NC}"
        
        # Salva em arquivo se especificado
        if [ -n "$output_file" ]; then
            cp "$temp_dir/validated.txt" "$output_file"
            log "INFO" "Resultados salvos em: $output_file"
        fi
    else
        # Mostra subdomínios encontrados mesmo que não sejam válidos em formato de tabela
        if [ -s "$temp_dir/subs.txt" ]; then
            while IFS= read -r subdomain; do
                # Adiciona https:// se não tiver protocolo
                if [[ ! "$subdomain" =~ ^https?:// ]]; then
                    url="https://$subdomain"
                else
                    url="$subdomain"
                fi
                
                # Trunca URL se muito longa
                url=$(echo "$url" | cut -c1-50)
                
                printf "${BLUE}│ ${NC}%-50s ${BLUE}│ ${YELLOW}%-8s ${BLUE}│ ${NC}%-15s ${BLUE}│ ${NC}%-20s ${BLUE}│ ${NC}%-30s ${BLUE}│${NC}\n" "$url" "N/A" "N/A" "N/A" "Não validado"
            done < "$temp_dir/subs.txt"
            
            local total_count=$(wc -l < "$temp_dir/subs.txt")
            echo -e "\n${CYAN}Total de Subdomínios Encontrados: ${YELLOW}$total_count${NC}"
            echo -e "${YELLOW}Nota: Subdomínios não validados (httpx não disponível)${NC}"
        else
            printf "${BLUE}│ ${NC}%-50s ${BLUE}│ ${RED}%-8s ${BLUE}│ ${NC}%-15s ${BLUE}│ ${NC}%-20s ${BLUE}│ ${NC}%-30s ${BLUE}│${NC}\n" "Nenhum subdomínio encontrado" "N/A" "N/A" "N/A" "N/A"
        fi
    fi
    
    echo -e "\n${GREEN}Scan em https://www.${domain} concluído com êxito${NC}"
    
    # Limpeza
    rm -rf "$temp_dir"
}

# Executa função principal
main "$@"
